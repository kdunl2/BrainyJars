"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(require("react"));

var _atomize = _interopRequireDefault(require("@quarkly/atomize"));

var _ComponentNotice = _interopRequireDefault(require("./ComponentNotice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var Source = _atomize["default"].source();

var SourceComponent = function SourceComponent(_ref) {
  var container = _ref.container,
      src = _ref.src,
      srcSet = _ref.srcSet,
      typeMedia = _ref.typeMedia,
      typePicture = _ref.typePicture,
      codecs = _ref.codecs,
      mediaInput = _ref.mediaInput,
      mediaSelect = _ref.mediaSelect,
      sizes = _ref.sizes,
      children = _ref.children,
      props = _objectWithoutProperties(_ref, ["container", "src", "srcSet", "typeMedia", "typePicture", "codecs", "mediaInput", "mediaSelect", "sizes", "children"]);

  var type = '';

  if (container !== 'picture') {
    type = "".concat(typeMedia || '').concat(typeMedia && codecs ? "; codecs='".concat(codecs, "'") : '');
  } else {
    type = typePicture || '';
  }

  return container ? /*#__PURE__*/_react["default"].createElement(Source, _extends({}, props, {
    src: src,
    srcSet: srcSet,
    type: type,
    media: container !== 'picture' ? mediaInput || mediaSelect : '',
    sizes: container !== 'picture' ? sizes : ''
  })) : /*#__PURE__*/_react["default"].createElement(_ComponentNotice["default"], _extends({
    message: 'This component should be inside Picture, Audio or Video'
  }, props));
};

var propInfo = {
  src: {
    title: {
      en: 'Audio or video file link',
      ru: 'Ссылка на аудио или видео файл'
    },
    control: 'input',
    type: 'text',
    category: 'Audio / Video',
    weight: 1
  },
  typeMedia: {
    title: {
      en: 'MIME type audio or video',
      ru: 'MIME-тип аудио или видео контента'
    },
    control: 'input',
    variants: ['video/mp4', 'video/webm', 'video/ogg', 'audio/mpeg', 'audio/midi', 'audio/wav', 'audio/ogg'],
    type: 'text',
    category: 'Audio / Video',
    weight: 1
  },
  codecs: {
    title: {
      en: 'Audio and video codecs',
      ru: 'Аудио или видео кодеки'
    },
    description: {
      en: 'Audio and video codecs (comma-separated, optional)',
      ru: 'Аудио и видео кодеки (через запятую, опционально)'
    },
    control: 'input',
    type: 'text',
    category: 'Audio / Video',
    weight: 1
  },
  srcSet: {
    title: {
      en: 'Image sources',
      ru: 'Источники изображений'
    },
    description: {
      en: 'One or more image sources with descriptors',
      ru: 'Один или несколько источников изображений с дескрипторами'
    },
    control: 'srcSet',
    multiply: true,
    category: 'Picture',
    weight: 1
  },
  sizes: {
    title: {
      en: 'Container size',
      ru: 'Размеры контейнера'
    },
    description: {
      en: 'Image slot sizes from srcSet for different breakpoints',
      ru: 'Размеры контейнера изображения из srcSet для различных брейкпоинтов'
    },
    control: 'sizes',
    multiply: true,
    category: 'Picture',
    weight: 1
  },
  mediaSelect: {
    title: {
      en: 'Device category',
      ru: 'Категория устройства'
    },
    control: 'select',
    variants: [{
      title: {
        en: 'All',
        ru: 'Все'
      },
      value: 'all'
    }, {
      title: {
        en: 'Print',
        ru: 'Печать'
      },
      value: 'print'
    }, {
      title: {
        en: 'Screen',
        ru: 'Экран'
      },
      value: 'screen'
    }, {
      title: {
        en: 'Speech',
        ru: 'Речь'
      },
      value: 'speech'
    }],
    category: 'Picture',
    weight: 0.4
  },
  mediaInput: {
    title: {
      en: 'Media query for image download',
      ru: 'Медиа запрос для вывода изображения'
    },
    control: 'input',
    type: 'text',
    category: 'Picture',
    weight: 0.6
  },
  typePicture: {
    title: {
      en: 'MIME type image',
      ru: 'MIME-тип изображения'
    },
    control: 'input',
    variants: ['image/webp', 'image/png', 'image/bmp', 'image/jpeg', 'image/gif', 'image/tiff', 'image/pict'],
    category: 'Picture',
    weight: 1
  }
};
var defaultProps = {
  mediaSelect: 'all'
};
Object.assign(SourceComponent, {
  title: 'Source',
  description: {
    en: 'This component helps you add multiple media sources',
    ru: 'Компонент для добавления нескольких медиа-ресурсов'
  },
  propInfo: propInfo,
  defaultProps: defaultProps
});
var _default = SourceComponent;
exports["default"] = _default;