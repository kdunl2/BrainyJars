"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _components = require("@quarkly/components");

var _widgets = require("@quarkly/widgets");

var _ComponentNotice = _interopRequireDefault(require("./ComponentNotice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var overrides = {
  Item: {
    kind: 'Box',
    props: {
      flex: '1 0  auto',
      'text-align': 'center'
    }
  },
  Value: {
    props: {
      'font-size': '40px',
      'font-weight': '900'
    }
  },
  Title: {
    kind: 'Text',
    props: {
      'font-weight': '300'
    }
  },
  Text: {
    kind: 'Text',
    props: {
      children: 'Указанное время достигнуто',
      flex: '1 0 100%',
      'text-align': 'center'
    }
  }
}; // Регулярка на проверку формата даты
// Принимает следующие форматы: 01-01-1970, 01.01.1970, 01/01/1970
// Также, проверяет кол-во месяцев и дней, с учетом высокосных лет

var regDate = /^(?:(?:31(\/|-|\.)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/|-|\.)(?:0?[13-9]|1[0-2])\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})$|^(?:29(\/|-|\.)0?2\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\d|2[0-8])(\/|-|\.)(?:(?:0?[1-9])|(?:1[0-2]))\4(?:(?:1[6-9]|[2-9]\d)?\d{2})$/; // Регулярка на проверку формата времени
// Принимает следующий формат 00:00

var regTime = /^(([0,1][0-9])|(2[0-3])):[0-5][0-9]$/; // Приведение значения к двузначному представленю

var addZero = function addZero(num) {
  return num < 10 ? "0".concat(num) : num;
}; // Получение оставшегося времени для вывода


var setDifferenceDate = function setDifferenceDate(targetDate, date) {
  var remOfDays = Math.ceil((targetDate - date) / 1000);
  var remOfHours = remOfDays % (60 * 60 * 24);
  var remOfMinutes = remOfHours % (60 * 60);
  var remOfSeconds = remOfMinutes % 60;
  return {
    day: addZero(Math.floor(remOfDays / (60 * 60 * 24))),
    hour: addZero(Math.floor(remOfHours / (60 * 60))),
    min: addZero(Math.floor(remOfMinutes / 60)),
    sec: addZero(remOfSeconds)
  };
};

var date = new Date();
var defaultDate = {
  day: '00',
  hour: '00',
  min: '00',
  sec: '00'
};

var TimerComponent = function TimerComponent(_ref) {
  var toDate = _ref.toDate,
      toTime = _ref.toTime,
      showDays = _ref.showDays,
      showHours = _ref.showHours,
      showMinutes = _ref.showMinutes,
      showSeconds = _ref.showSeconds,
      showTextDone = _ref.showTextDone,
      props = _objectWithoutProperties(_ref, ["toDate", "toTime", "showDays", "showHours", "showMinutes", "showSeconds", "showTextDone"]);

  var _useOverrides = (0, _components.useOverrides)(props, overrides),
      override = _useOverrides.override,
      rest = _useOverrides.rest;

  var _useState = (0, _react.useState)(false),
      _useState2 = _slicedToArray(_useState, 2),
      isDone = _useState2[0],
      setDone = _useState2[1];

  var _useState3 = (0, _react.useState)(defaultDate),
      _useState4 = _slicedToArray(_useState3, 2),
      dateState = _useState4[0],
      setDate = _useState4[1];

  var isAlways = (0, _react.useMemo)(function () {
    return showTextDone === 'always';
  }, [showTextDone]);
  var isComplete = (0, _react.useMemo)(function () {
    return showTextDone === 'complete' && isDone;
  }, [showTextDone, isDone]);
  var showList = (0, _react.useMemo)(function () {
    return [{
      key: 'day',
      name: 'Days',
      show: showDays
    }, {
      key: 'hour',
      name: 'Hours',
      show: showHours
    }, {
      key: 'min',
      name: 'Minutes',
      show: showMinutes
    }, {
      key: 'sec',
      name: 'Seconds',
      show: showSeconds
    }];
  }, [showDays, showHours, showMinutes, showSeconds]);
  (0, _react.useEffect)(function () {
    var currentDate = new Date();
    var year;
    var month;
    var day;
    var hour;
    var min;
    var regDateStatus = regDate.test(toDate.trim());
    var regTimeStatus = regTime.test(toTime.trim());

    if (regDateStatus) {
      var targetArr = toDate.split(/[.,/ -]/);
      year = targetArr[2]; // eslint-disable-line

      month = targetArr[1] - 1;
      day = targetArr[0]; // eslint-disable-line
    } else {
      year = currentDate.getFullYear();
      month = currentDate.getMonth();
      day = currentDate.getDate();
    }

    if (regTimeStatus) {
      var _targetArr = toTime.split(/[:]/);

      var _targetArr2 = _slicedToArray(_targetArr, 2);

      hour = _targetArr2[0];
      min = _targetArr2[1];
    } else {
      hour = date.getHours();
      min = date.getMinutes();
    }

    var targetDate = new Date(year, month, day, hour, min);
    setDone(false);
    var timerID = setInterval(function () {
      var nowDate = Date.now();

      if (targetDate > nowDate) {
        setDate(setDifferenceDate(targetDate, nowDate));
      } else {
        clearInterval(timerID);
        setDone(true);
        setDate(defaultDate);
      }
    }, 1000);
    return function () {
      clearInterval(timerID);
    };
  }, [toDate, toTime]);
  return /*#__PURE__*/_react["default"].createElement(_widgets.Box, _extends({
    width: "100%",
    display: "flex",
    "flex-wrap": "wrap"
  }, rest), !isAlways && !isComplete ? showList.map(function (item) {
    return item.show && /*#__PURE__*/_react["default"].createElement(_widgets.Box, _extends({
      key: item.key
    }, override('Item')), /*#__PURE__*/_react["default"].createElement(_widgets.Text, override('Value', "Value ".concat(item.name)), dateState[item.key]), /*#__PURE__*/_react["default"].createElement(_widgets.Text, override('Title', "Title ".concat(item.name)), override("Title ".concat(item.name)).children || item.name));
  }) : /*#__PURE__*/_react["default"].createElement(_widgets.Text, override('Text')), !showList.find(function (item) {
    return item.show;
  }) && /*#__PURE__*/_react["default"].createElement(_ComponentNotice["default"], {
    message: "You hid all the output values of the timer!"
  }));
};

var propInfo = {
  toDate: {
    title: {
      en: 'End date',
      ru: 'Дата окончания'
    },
    description: {
      en: 'Timer end date (in the dd.mm.yyyy.format)',
      ru: 'Дата окончания таймера (в формате дд-мм-гггг)'
    },
    control: 'input',
    category: 'Main',
    weight: 0.5
  },
  toTime: {
    title: {
      en: 'End time',
      ru: 'Время окончания'
    },
    description: {
      en: 'Timer end time (in the hh:mm format)',
      ru: 'Время окончания таймера (в формате чч:мм)'
    },
    control: 'input',
    category: 'Main',
    weight: 0.5
  },
  showDays: {
    title: {
      en: "Show 'Days'",
      ru: "Показать 'Дни'"
    },
    control: 'checkbox',
    category: 'Main',
    weight: 0.5
  },
  showHours: {
    title: {
      en: "Show 'Hours'",
      ru: "Показать 'Часы'"
    },
    control: 'checkbox',
    category: 'Main',
    weight: 0.5
  },
  showMinutes: {
    title: {
      en: "Show 'Minutes'",
      ru: "Показать 'Минуты'"
    },
    control: 'checkbox',
    category: 'Main',
    weight: 0.5
  },
  showSeconds: {
    title: {
      en: "Show 'Seconds'",
      ru: "Показать 'Секунды'"
    },
    control: 'checkbox',
    category: 'Main',
    weight: 0.5
  },
  showTextDone: {
    title: {
      en: 'When display the message',
      ru: 'Когда показывать сообщение'
    },
    control: 'radio-group',
    variants: [{
      title: {
        en: 'Always',
        ru: 'Всегда'
      },
      value: 'always'
    }, {
      title: {
        en: 'At the end of the timer',
        ru: 'По завершении таймера'
      },
      value: 'complete'
    }, {
      title: {
        en: 'Never',
        ru: 'Никогда'
      },
      value: 'never'
    }],
    category: 'Main',
    weight: 1
  }
};
var defaultDateProp = "".concat(addZero(date.getDate() + 1), ".").concat(addZero(date.getMonth() + 1), ".").concat(addZero(date.getFullYear()));
var defaultTimeProp = "".concat(addZero(date.getHours()), ":").concat(addZero(date.getMinutes()));
var defaultProps = {
  toDate: defaultDateProp,
  toTime: defaultTimeProp,
  showDays: true,
  showHours: true,
  showMinutes: true,
  showSeconds: true,
  showTextDone: 'complete'
};
Object.assign(TimerComponent, {
  title: 'Timer',
  description: {
    en: 'Timer lets you site visitor know about the start and the end of an event',
    ru: 'Счетчик обратного отсчета проинформирует посетителя об оставшемся времени до начала или окончания события'
  },
  propInfo: propInfo,
  defaultProps: defaultProps,
  overrides: overrides
});
var _default = TimerComponent;
exports["default"] = _default;