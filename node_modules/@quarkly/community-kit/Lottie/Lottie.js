"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _lottieWeb = _interopRequireDefault(require("lottie-web"));

var _widgets = require("@quarkly/widgets");

var _props = require("./props");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var Lottie = function Lottie(_ref) {
  var path = _ref.path,
      loop = _ref.loop,
      isStopped = _ref.isStopped,
      isPaused = _ref.isPaused,
      firstFrame = _ref.firstFrame,
      lastFrame = _ref.lastFrame,
      forceUpdate = _ref.forceUpdate,
      speed = _ref.speed,
      renderer = _ref.renderer,
      props = _objectWithoutProperties(_ref, ["path", "loop", "isStopped", "isPaused", "firstFrame", "lastFrame", "forceUpdate", "speed", "renderer"]);

  var ref = (0, _react.useRef)();
  var animRef = (0, _react.useRef)(null);
  var playFromTheBeginning = (0, _react.useCallback)(function () {
    if (!animRef.current) return;

    if (!!firstFrame || !!lastFrame) {
      animRef.current.playSegments([parseInt(firstFrame || 0, 10), parseInt(lastFrame || animRef.current.totalFrames, 10)], forceUpdate);
    } else {
      animRef.current.resetSegments(forceUpdate);
      animRef.current.play();
    }
  }, [firstFrame, lastFrame, forceUpdate]);

  var loadAnimation = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var _animRef$current;

      var _animRef$current2, _animRef$current3;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              (_animRef$current = animRef.current) === null || _animRef$current === void 0 ? void 0 : _animRef$current.destroy();
              animRef.current = _lottieWeb["default"].loadAnimation({
                container: ref.current,
                autoplay: false,
                renderer: renderer,
                loop: loop,
                path: path
              });
              animRef.current.setSpeed(speed);
              _context.next = 5;
              return (0, _utils.waitDOMLoaded)(animRef.current);

            case 5:
              if (isStopped) {
                (_animRef$current2 = animRef.current) === null || _animRef$current2 === void 0 ? void 0 : _animRef$current2.stop();
              } else if (isPaused) {
                (_animRef$current3 = animRef.current) === null || _animRef$current3 === void 0 ? void 0 : _animRef$current3.pause();
              } else {
                playFromTheBeginning();
              }

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function loadAnimation() {
      return _ref2.apply(this, arguments);
    };
  }(); // Reload animation when the route or rendering method is changed


  (0, _react.useLayoutEffect)(function () {
    if (!path || !renderer) return;
    loadAnimation();
    return function () {
      var _animRef$current4;

      return (_animRef$current4 = animRef.current) === null || _animRef$current4 === void 0 ? void 0 : _animRef$current4.destroy();
    }; // eslint-disable-next-line
  }, [path, renderer]); // Toggle animation loop

  (0, _utils.useUpdateEffect)(function () {
    if (!animRef.current) return;
    animRef.current.loop = loop;

    if (loop && animRef.current.isPaused) {
      playFromTheBeginning();
    }
  }, [loop, playFromTheBeginning]); // Start, pause and stop animation

  (0, _utils.useUpdateEffect)(function () {
    if (isStopped) {
      var _animRef$current5;

      (_animRef$current5 = animRef.current) === null || _animRef$current5 === void 0 ? void 0 : _animRef$current5.stop();
    } else if (isPaused) {
      var _animRef$current6;

      (_animRef$current6 = animRef.current) === null || _animRef$current6 === void 0 ? void 0 : _animRef$current6.pause();
    } else {
      var _animRef$current7;

      (_animRef$current7 = animRef.current) === null || _animRef$current7 === void 0 ? void 0 : _animRef$current7.play();
    }
  }, [isStopped, isPaused]); // // Change animation speed

  (0, _utils.useUpdateEffect)(function () {
    var _animRef$current8;

    (_animRef$current8 = animRef.current) === null || _animRef$current8 === void 0 ? void 0 : _animRef$current8.setSpeed(speed);
  }, [speed]);
  return /*#__PURE__*/_react["default"].createElement(_widgets.Box, _extends({
    ref: ref,
    margin: "0 auto",
    outline: "none",
    overflow: "hidden",
    position: renderer === 'html' && 'relative'
  }, props));
};

Object.assign(Lottie, {
  title: 'Lottie',
  description: {
    en: 'This component is used for adding lightweight and scalable Lottie animations to your website',
    ru: 'Компонент для добавления легких и масштабируемых анимаций Lottie для вашего сайта'
  },
  propInfo: _props.propInfo,
  defaultProps: _props.defaultProps
});
var _default = Lottie;
exports["default"] = _default;