"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _dateFns = require("date-fns");

var _DatePickerContext = _interopRequireDefault(require("./DatePickerContext"));

var _DatePickerReducer = _interopRequireDefault(require("./DatePickerReducer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var defaultMinDate = new Date('1900-01-01');
var defaultMaxDate = new Date('2100-01-01');
var modifiers = {
  ArrowUp: function ArrowUp(val) {
    return (0, _dateFns.addWeeks)(val, -1);
  },
  ArrowDown: function ArrowDown(val) {
    return (0, _dateFns.addWeeks)(val, 1);
  },
  ArrowLeft: function ArrowLeft(val) {
    return (0, _dateFns.addDays)(val, -1);
  },
  ArrowRight: function ArrowRight(val) {
    return (0, _dateFns.addDays)(val, 1);
  },
  PageUp: function PageUp(val) {
    return (0, _dateFns.addMonths)(val, -1);
  },
  PageDown: function PageDown(val) {
    return (0, _dateFns.addMonths)(val, 1);
  },
  Home: function Home(val) {
    return (0, _dateFns.setDate)(val, 1);
  },
  End: function End(val) {
    return (0, _dateFns.setDate)(val, (0, _dateFns.lastDayOfMonth)(val).getDate());
  }
};

var DatePickerProvider = function DatePickerProvider(_ref) {
  var children = _ref.children,
      showOutsideDays = _ref.showOutsideDays,
      numberOfMonths = _ref.numberOfMonths,
      mode = _ref.mode,
      minDate = _ref.minDate,
      maxDate = _ref.maxDate,
      disabledDates = _ref.disabledDates,
      disabledDaysOfWeek = _ref.disabledDaysOfWeek,
      initialMonth = _ref.initialMonth,
      locale = _ref.locale;

  var _useReducer = (0, _react.useReducer)(_DatePickerReducer["default"], {
    focused: null,
    showOutsideDays: showOutsideDays,
    numberOfMonths: numberOfMonths !== null && numberOfMonths !== void 0 ? numberOfMonths : 1,
    mode: mode !== null && mode !== void 0 ? mode : 'single',
    monthDate: (0, _dateFns.isValid)(initialMonth) ? initialMonth : new Date(),
    minDate: (0, _dateFns.isValid)(minDate) ? minDate : defaultMinDate,
    maxDate: (0, _dateFns.isValid)(maxDate) ? maxDate : defaultMaxDate,
    disabledDates: disabledDates !== null && disabledDates !== void 0 ? disabledDates : [],
    disabledDaysOfWeek: disabledDaysOfWeek !== null && disabledDaysOfWeek !== void 0 ? disabledDaysOfWeek : [],
    locale: locale
  }),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];

  var setMonthDate = (0, _react.useCallback)(function (monthDate) {
    dispatch({
      type: 'SET_MONTH_DATE',
      payload: monthDate
    });
  }, []);
  var handleDayFocus = (0, _react.useCallback)(function (day) {
    dispatch({
      type: 'SET_FOCUS',
      payload: day
    });
  }, []);
  var handleDayKeyDown = (0, _react.useCallback)(function (event) {
    var modifier = modifiers[event.key];
    if (!modifier) return;
    dispatch({
      type: 'MODIFY_FOCUS',
      payload: modifier
    });
  }, []);
  var nextMonth = (0, _react.useCallback)(function () {
    dispatch({
      type: 'MODIFY_MONTH',
      payload: 'NEXT'
    });
  }, []);
  var prevMonth = (0, _react.useCallback)(function () {
    dispatch({
      type: 'MODIFY_MONTH',
      payload: 'PREV'
    });
  }, []);
  (0, _react.useEffect)(function () {
    dispatch({
      type: 'STATE_UPDATE',
      payload: {
        showOutsideDays: showOutsideDays,
        numberOfMonths: numberOfMonths >= 1 ? numberOfMonths : 1,
        minDate: (0, _dateFns.isValid)(minDate) ? minDate : defaultMinDate,
        maxDate: (0, _dateFns.isValid)(maxDate) ? maxDate : defaultMaxDate,
        disabledDates: disabledDates !== null && disabledDates !== void 0 ? disabledDates : [],
        disabledDaysOfWeek: disabledDaysOfWeek !== null && disabledDaysOfWeek !== void 0 ? disabledDaysOfWeek : [],
        locale: locale
      }
    });
  }, [showOutsideDays, numberOfMonths, minDate, maxDate, disabledDates, disabledDaysOfWeek, locale]); // Обновление начального месяца вынес отдельно, чтобы избежать ресета календаря при динамической смене языка или disabledDates

  (0, _react.useEffect)(function () {
    var monthDate = (0, _dateFns.isValid)(initialMonth) ? initialMonth : new Date();
    dispatch({
      type: 'STATE_UPDATE',
      payload: {
        monthDate: monthDate
      }
    });
  }, [initialMonth]);
  var contextValue = (0, _react.useMemo)(function () {
    return {
      showOutsideDays: state.showOutsideDays,
      numberOfMonths: state.numberOfMonths,
      mode: state.mode,
      monthDate: state.monthDate,
      locale: state.locale,
      selected: state.selected,
      focused: state.focused,
      maxDate: state.maxDate,
      minDate: state.minDate,
      disabledDaysOfWeek: state.disabledDaysOfWeek,
      disabledDates: state.disabledDates,
      setMonthDate: setMonthDate,
      nextMonth: nextMonth,
      prevMonth: prevMonth,
      handleDayFocus: handleDayFocus,
      handleDayKeyDown: handleDayKeyDown
    };
  }, [state.showOutsideDays, state.numberOfMonths, state.mode, state.monthDate, state.locale, state.selected, state.focused, state.maxDate, state.minDate, state.disabledDaysOfWeek, state.disabledDates, setMonthDate, nextMonth, prevMonth, handleDayFocus, handleDayKeyDown]);
  return /*#__PURE__*/_react["default"].createElement(_DatePickerContext["default"].Provider, {
    value: contextValue
  }, children);
};

var _default = DatePickerProvider;
exports["default"] = _default;