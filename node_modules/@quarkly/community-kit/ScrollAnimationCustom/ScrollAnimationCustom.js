"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _widgets = require("@quarkly/widgets");

var _components = require("@quarkly/components");

var _ComponentNotice = _interopRequireDefault(require("../ComponentNotice"));

var _utils = require("../utils");

var _props = require("./props");

var _useScript2 = _interopRequireDefault(require("./hooks/useScript"));

var _makeAnim = _interopRequireDefault(require("./utils/makeAnim"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var duration = 1000; // Totally arbitrary!

/* global ScrollTimeline */

var ScrollAnimationCustom = function ScrollAnimationCustom(_ref) {
  var startTrigger = _ref.startTrigger,
      startBorder = _ref.startBorder,
      endTrigger = _ref.endTrigger,
      endBorder = _ref.endBorder,
      easing = _ref.easing,
      transformEnabled = _ref.transformEnabled,
      transformStart = _ref.transformStart,
      transformEnd = _ref.transformEnd,
      colorEnabled = _ref.colorEnabled,
      colorStart = _ref.colorStart,
      colorEnd = _ref.colorEnd,
      opacityEnabled = _ref.opacityEnabled,
      opacityStart = _ref.opacityStart,
      opacityEnd = _ref.opacityEnd,
      filterEnabled = _ref.filterEnabled,
      filterStart = _ref.filterStart,
      filterEnd = _ref.filterEnd,
      backgroundEnabled = _ref.backgroundEnabled,
      backgroundStart = _ref.backgroundStart,
      backgroundEnd = _ref.backgroundEnd,
      borderColorEnabled = _ref.borderColorEnabled,
      borderColorStart = _ref.borderColorStart,
      borderColorEnd = _ref.borderColorEnd,
      boxShadowEnabled = _ref.boxShadowEnabled,
      boxShadowStart = _ref.boxShadowStart,
      boxShadowEnd = _ref.boxShadowEnd,
      props = _objectWithoutProperties(_ref, ["startTrigger", "startBorder", "endTrigger", "endBorder", "easing", "transformEnabled", "transformStart", "transformEnd", "colorEnabled", "colorStart", "colorEnd", "opacityEnabled", "opacityStart", "opacityEnd", "filterEnabled", "filterStart", "filterEnd", "backgroundEnabled", "backgroundStart", "backgroundEnd", "borderColorEnabled", "borderColorStart", "borderColorEnd", "boxShadowEnabled", "boxShadowStart", "boxShadowEnd"]);

  var _useOverrides = (0, _components.useOverrides)(props, _props.overrides),
      override = _useOverrides.override,
      children = _useOverrides.children,
      rest = _useOverrides.rest;

  var isEmpty = (0, _react.useMemo)(function () {
    return (0, _utils.isEmptyChildren)(children);
  }, [children]);
  var contentRef = (0, _react.useRef)({});
  var wrapperRef = (0, _react.useRef)({});
  var animationRef = (0, _react.useRef)();

  var _useScript = (0, _useScript2["default"])('https://rawcdn.githack.com/flackr/scroll-timeline/dbae321ec0130a6ce19c8fe9c428755cfc15049c/dist/scroll-timeline.js'),
      ready = _useScript.ready;

  (0, _react.useEffect)(function () {
    var _animationRef$current;

    if (!ready) return;
    var endMargin = "".concat(-1 * (parseFloat(endBorder) || 0), "%");
    var startMargin = "".concat(-1 * (100 - (parseFloat(startBorder) || 0)), "%");
    (_animationRef$current = animationRef.current) === null || _animationRef$current === void 0 ? void 0 : _animationRef$current.cancel();

    var animation = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, (0, _makeAnim["default"])('transform', transformEnabled, transformStart, transformEnd)), (0, _makeAnim["default"])('opacity', opacityEnabled, opacityStart, opacityEnd)), (0, _makeAnim["default"])('color', colorEnabled, colorStart, colorEnd)), (0, _makeAnim["default"])('filter', filterEnabled, filterStart, filterEnd)), (0, _makeAnim["default"])('background', backgroundEnabled, backgroundStart, backgroundEnd)), (0, _makeAnim["default"])('borderColor', borderColorEnabled, borderColorStart, borderColorEnd)), (0, _makeAnim["default"])('boxShadow', boxShadowEnabled, boxShadowStart, boxShadowEnd)), {}, {
      easing: easing
    });

    var scrollOffsets = [{
      target: wrapperRef.current,
      edge: 'end',
      rootMargin: "0% 0% ".concat(startMargin, " 0%"),
      threshold: startTrigger === 'bottom' ? 1 : 0,
      clamp: true
    }, {
      target: wrapperRef.current,
      edge: 'start',
      rootMargin: "".concat(endMargin, " 0% 0% 0%"),
      threshold: endTrigger === 'top' ? 1 : 0,
      clamp: true
    }];
    var scrollTimeline = new ScrollTimeline({
      scrollOffsets: scrollOffsets,
      fill: 'both'
    });
    animationRef.current = contentRef.current.animate(animation, {
      duration: duration,
      fill: 'both',
      timeline: scrollTimeline
    });
  }, [ready, startTrigger, startBorder, endTrigger, endBorder, easing, transformEnabled, transformStart, transformEnd, opacityEnabled, opacityStart, opacityEnd, colorEnabled, colorStart, colorEnd, filterEnabled, filterStart, filterEnd, backgroundEnabled, backgroundStart, backgroundEnd, borderColorEnabled, borderColorStart, borderColorEnd, boxShadowEnabled, boxShadowStart, boxShadowEnd]);
  return /*#__PURE__*/_react["default"].createElement(_widgets.Box, _extends({
    ref: wrapperRef
  }, rest), /*#__PURE__*/_react["default"].createElement(_widgets.Box, _extends({
    ref: contentRef
  }, override('Content')), children, isEmpty && /*#__PURE__*/_react["default"].createElement(_ComponentNotice["default"], {
    message: "Add child component to make animation work"
  })));
};

Object.assign(ScrollAnimationCustom, {
  title: 'ScrollAnimationCustom',
  description: {
    ru: 'Компонент для анимации одного или нескольких элементов во время прокрутки страницы.',
    en: 'Use this component to animate one or several elements on page scroll.'
  },
  propInfo: _props.propInfo,
  defaultProps: _props.defaultProps
});
var _default = ScrollAnimationCustom;
exports["default"] = _default;