"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _atomize = _interopRequireDefault(require("@quarkly/atomize"));

var _components = require("@quarkly/components");

var _widgets = require("@quarkly/widgets");

var _templateObject, _templateObject2;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var overrides = {
  Bground: {
    kind: 'Bground',
    props: {
      top: '0',
      right: '0',
      bottom: '0',
      left: '0',
      width: '100%',
      height: '100%',
      position: 'absolute',
      'z-index': '1'
    }
  },
  Content: {
    kind: 'Content',
    props: {
      position: 'relative',
      'z-index': '2'
    }
  }
};

var useAnimationFrame = function useAnimationFrame(cb) {
  var requestRef = (0, _react.useRef)();
  var prevTimeRef = (0, _react.useRef)();

  var animate = function animate(time) {
    if (prevTimeRef.current !== undefined) {
      cb(time - prevTimeRef.current);
    }

    prevTimeRef.current = time;
    requestRef.current = requestAnimationFrame(animate);
  };

  (0, _react.useEffect)(function () {
    requestRef.current = requestAnimationFrame(animate);
    return function () {
      return cancelAnimationFrame(requestRef.current);
    };
  }, []); // eslint-disable-line
};

var Content = _atomize["default"].div(_templateObject || (_templateObject = _taggedTemplateLiteral([""])));

var Bground = _atomize["default"].div(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  will-change: transform;\n  transform: translate3d(0, 0, 0);\n"])));

var BgImageParallax = function BgImageParallax(_ref) {
  var imageURL = _ref.imageURL,
      imageSize = _ref.imageSize,
      imagePosition = _ref.imagePosition,
      imageRepeat = _ref.imageRepeat,
      scrollSpeedProp = _ref.scrollSpeedProp,
      scrollInertiaProp = _ref.scrollInertiaProp,
      scrollDirection = _ref.scrollDirection,
      props = _objectWithoutProperties(_ref, ["imageURL", "imageSize", "imagePosition", "imageRepeat", "scrollSpeedProp", "scrollInertiaProp", "scrollDirection"]);

  var _useOverrides = (0, _components.useOverrides)(props, overrides),
      override = _useOverrides.override,
      children = _useOverrides.children,
      rest = _useOverrides.rest;

  var wrapperRef = (0, _react.useRef)();
  var bgroundRef = (0, _react.useRef)();
  var bgroundPos = (0, _react.useRef)({});
  var scrollSpeed = (0, _react.useMemo)(function () {
    var numb = parseFloat(scrollSpeedProp);
    return !Number.isNaN(numb) ? Math.abs(numb) : 1;
  }, [scrollSpeedProp]);
  var scrollInertia = (0, _react.useMemo)(function () {
    var numb = parseInt(scrollInertiaProp, 10);
    return numb > 1 ? numb : 1;
  }, [scrollInertiaProp]);
  var updateParallaxTop = (0, _react.useCallback)(function () {
    if (!wrapperRef.current) return;

    var _wrapperRef$current$g = wrapperRef.current.getBoundingClientRect(),
        top = _wrapperRef$current$g.top,
        height = _wrapperRef$current$g.height;

    var windowHeight = window.innerHeight;
    var isInViewport = top < windowHeight && top + height >= 0;
    if (!isInViewport) return;
    var direction = 1; // scrollDirection === 'inverse' ? -1 : 1;

    var scrollShift = top * (direction * scrollSpeed - 1);
    var windowShift = windowHeight * (scrollSpeed > 1 ? scrollSpeed - 1 : 0);
    bgroundPos.current.scrollTop = scrollShift - windowShift;
  }, [scrollSpeed]);
  var setParallaxHeight = (0, _react.useCallback)(function () {
    if (!wrapperRef.current) return;

    var _wrapperRef$current$g2 = wrapperRef.current.getBoundingClientRect(),
        height = _wrapperRef$current$g2.height;

    var windowHeight = window.innerHeight;
    var shiftHeight = windowHeight * Math.abs(1 - scrollSpeed);
    var imageHeight = height * scrollSpeed + shiftHeight;
    bgroundRef.current.style.height = "".concat(imageHeight, "px");
  }, [wrapperRef.current, scrollSpeed]); // eslint-disable-line

  (0, _react.useEffect)(function () {
    document.addEventListener('scroll', updateParallaxTop);
    return function cleanup() {
      document.removeEventListener('scroll', updateParallaxTop);
    };
  }, [updateParallaxTop]);
  (0, _react.useEffect)(function () {
    updateParallaxTop();
    setParallaxHeight();
  }, [updateParallaxTop, setParallaxHeight]);
  useAnimationFrame(function () {
    if (!bgroundRef.current) return;
    var _bgroundPos$current = bgroundPos.current,
        scrollTop = _bgroundPos$current.scrollTop,
        _bgroundPos$current$b = _bgroundPos$current.bgroundTop,
        bgroundTop = _bgroundPos$current$b === void 0 ? scrollTop - 1 : _bgroundPos$current$b;

    if (scrollTop && scrollTop !== bgroundTop) {
      if (scrollInertia === 1) {
        bgroundPos.current.bgroundTop = scrollTop;
      } else {
        bgroundPos.current.bgroundTop = bgroundTop + (scrollTop - bgroundTop) / scrollInertia;
      }

      bgroundRef.current.style.transform = "translate3d(0, ".concat(bgroundPos.current.bgroundTop, "px, 0)");
    }
  });
  return /*#__PURE__*/_react["default"].createElement(_widgets.Box, _extends({
    position: "relative",
    overflow: "hidden"
  }, rest, {
    ref: wrapperRef
  }), /*#__PURE__*/_react["default"].createElement(Bground, _extends({
    ref: bgroundRef,
    background: "transparent url(".concat(imageURL, ") ").concat(imagePosition, " top/").concat(imageSize, " ").concat(imageRepeat)
  }, override('Bground'))), /*#__PURE__*/_react["default"].createElement(Content, override('Content'), children));
};

var propInfo = {
  imageURL: {
    title: {
      en: 'Image',
      ru: 'Изображение'
    },
    control: 'image',
    category: 'Image',
    weight: 1
  },
  imageSize: {
    title: {
      en: 'Image size',
      ru: 'Размер изображения'
    },
    control: 'input',
    variants: ['cover', '100%', '150%', '200%', '250%'],
    category: 'Image',
    weight: 0.5
  },
  imagePosition: {
    title: {
      en: 'Image alignment',
      ru: 'Выравнивание изображения'
    },
    control: 'radio-group',
    variants: ['left', 'center', 'right'],
    category: 'Image',
    weight: 0.5
  },
  imageRepeat: {
    title: {
      en: 'Repeat image',
      ru: 'Повтор изображения'
    },
    control: 'radio-group',
    variants: [{
      title: {
        en: 'Repeat',
        ru: 'Повторять'
      },
      value: 'repeat'
    }, {
      title: {
        en: "Don't repeat",
        ru: 'Не повторять'
      },
      value: 'no-repeat'
    }],
    category: 'Image',
    weight: 1
  },
  scrollSpeedProp: {
    title: {
      en: 'Scroll speed',
      ru: 'Скорость прокрутки'
    },
    control: 'input',
    variants: ['0', '0.25', '0.5', '0.75', '1', '2', '5', '10'],
    category: 'Scroll',
    weight: 0.5
  },
  scrollInertiaProp: {
    title: {
      en: 'Scroll inertia',
      ru: 'Инерция прокрутки'
    },
    control: 'input',
    variants: ['1', '2', '5', '10'],
    category: 'Scroll',
    weight: 0.5
  } // scrollDirection: {
  //   title: 'Направление прокрутки',
  //   control: 'radio-group',
  //   variants: ['normal', 'inverse'],
  //   category: 'Scroll',
  //   weight: 1
  // },

};
var defaultProps = {
  imageURL: '',
  imageSize: 'cover',
  imagePosition: 'center',
  imageRepeat: 'no-repeat',
  scrollSpeedProp: '0.5',
  scrollInertiaProp: '1' // scrollDirection: 'normal',

};
Object.assign(BgImageParallax, {
  title: 'Background image Parallax',
  description: {
    en: 'Use this component to create parallax effect',
    ru: 'Компонент для создания эффекта "параллакс" фонового изображения'
  },
  propInfo: propInfo,
  defaultProps: defaultProps,
  overrides: overrides
});
var _default = BgImageParallax;
exports["default"] = _default;